<?php

/**
 * Implements hook_menu().
 */
function cer_menu() {
  $items = array();
  $prefix = 'admin/config/content/cer';

  $items[$prefix] = array(
    'title' => 'Corresponding References',
    'page callback' => 'cer_preset_list',
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items["{$prefix}/presets"] = array(
    'title' => 'Presets',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 1,
  );
  $items["{$prefix}/presets/add"] = array(
    'title' => 'Add a preset',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cer_add_preset'),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_LOCAL_ACTION,
  );
  $items["{$prefix}/presets/toggle/%cer_preset"] = array(
    'page callback' => 'cer_preset_toggle',
    'page arguments' => array(6),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items["{$prefix}/presets/invert/%cer_preset"] = array(
    'page callback' => 'cer_preset_invert',
    'page arguments' => array(6),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items["{$prefix}/presets/delete/%cer_preset"] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cer_delete_preset', 6),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items["{$prefix}/update"] = array(
    'title' => 'Bulk Update',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cer_bulk_update_form'),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function cer_permission() {
  return array(
    'administer cer settings' => array(
      'title' => t('Administer corresponding entity references'),
    )
  );
}

function cer_preset_load($id = NULL) {
  if (isset($id)) {
    return new CerPreset(db_select('cer')->fields('cer')->condition('id', $id)->execute()->fetchObject());
  }
  else {
    return array_map(__FUNCTION__, db_select('cer')->fields('cer', array('id'))->execute()->fetchCol());
  }
}

/**
 * Implements hook_field_delete_instance().
 */
function cer_field_delete_instance(array $instance) {
  $pattern = sprintf('%%%s:%s:%s%%', $instance['entity_type'], $instance['bundle'], $instance['field_name']);
  db_query("DELETE FROM {cer} WHERE a LIKE :pattern OR b LIKE :pattern", array(':pattern' => $pattern));
}

/**
 * Implements hook_field_delete_field().
 */
function cer_field_delete_field(array $field) {
  $pattern = '%' . $field['field_name'] . '%';
  db_query("DELETE FROM {cer} WHERE a LIKE :pattern OR b LIKE :pattern", array(':pattern' => $pattern));
}

/**
 * Implements hook_node_insert().
 */
function cer_node_insert(StdClass $node) {
  // Write access grants *before* doing CER stuff in order to prevent a race condition.
  node_access_acquire_grants($node);

  cer_processing_entity('insert', $node, 'node');

  // Now allow node_save() to write the access grants cleanly.
  db_delete('node_access')->condition('nid', $node->nid)->execute();
}

/**
 * Implements hook_entity_insert().
 */
function cer_entity_insert($entity, $type) {
  if (! function_exists("cer_{$type}_insert")) {
    cer_processing_entity('insert', $entity, $type);
  }
}

/**
 * Implements hook_entity_update().
 */
function cer_entity_update($entity, $type) {
  if (! function_exists("cer_{$type}_update")) {
    cer_processing_entity('update', $entity, $type);
  }
}

/**
 * Implements hook_entity_delete().
 */
function cer_entity_delete($entity, $type) {
  if (! function_exists("cer_{$type}_delete")) {
    cer_processing_entity('delete', $entity, $type);
  }
}

/**
 * Process a entity's corresponding entity references.
 *
 * @param string $op 
 *  The operation being performed on the entity (insert, update, or delete).
 *
 * @param object $entity
 *  The entity.
 *
 * @param string $entity_type
 *  The entity type.
 *
 * @param array $context
 *  Either the Batch API context (since this is the callback function used
 *  during bulk update) or NULL if we're not in a batch job.
 */
function cer_processing_entity($op, $entity, $entity_type, array &$context = NULL) {
  if (is_integer($entity)) {
    $entity = entity_load($entity_type, array($entity));
    $entity = reset($entity);
  }
  
  module_load_include('inc', 'cer', 'cer.properties');

  $presets = new CER($entity_type, $entity);

  foreach ($presets as $key => $preset) {
    $preset->$op();
  }

  if ($context) {
    if (! isset($context['results']['count'])) {
      $context['results']['count'] = 0;
    }
    $context['results']['count']++;
  }
}

/**
 * Batch 'finished' callback.
 */
function cer_batch_update_existing_finished($success, $results, $operations) {
  if ($success) {
    $message = format_plural($results['count'], '1 entity processed.', '@count entities processed.');

    if (isset($results['errors'])) {
      $type = 'warning';
      foreach ($results['errors'] as $e) {
        drupal_set_message($e->getMessage(), 'error');
      }
    }
    else {
      $type = 'status';
    }
    drupal_set_message($message, $type);
  }
  else {
    // An error occurred. $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    $message = 'An error occurred while processing ' . $error_operation[0] . ' with arguments:' . print_r($error_operation[0], TRUE);
    drupal_set_message($message, 'error');
  }
}

/**
 * Implements hook_hook_info().
 */
function cer_hook_info() {
  return array(
    'cer_fields' => array(
      'group' => 'cer',
    ),
    'cer_preset_create' => array(
      'group' => 'cer',
    ),
    'cer_preset_delete' => array(
      'group' => 'cer',
    ),
  );
}

/**
 * Implements hook_query_TAG_alter().
 */
function cer_query_cer_field_parents_alter(QueryAlterableInterface $query) {
  $field = $query->getMetaData('field');
  
  // If the field is instantiated on a field collection, find the field
  // collection field(s) which contain this one.
  if ($field->inFieldCollection()) {
    $query
      ->condition('field_name', $field->instanceInfo('bundle'))
      ->addMetaData('class', 'CerFieldCollectionField');
  }
}

/**
 * Implements hook_entity_property_info().
 */
function cer_entity_property_info() {
  $properties = array();

  foreach (entity_get_info() as $entity_type => $entity_info) {
    $properties[$entity_type]['properties']['lineage'] = array(
      'label' => t('Context'),
      'description' => t("The entity's lineage, represented as a string."),
      'type' => 'text',
      'getter callback' => 'cer_get_entity_lineage',
      'computed' => TRUE,
    );

    $properties[$entity_type]['properties']['depth'] = array(
      'label' => t('Depth'),
      'description' => t("How deeply the entity is embedded."),
      'type' => 'integer',
      'getter callback' => 'cer_get_entity_depth',
      'computed' => TRUE,
    );

    $properties[$entity_type]['properties']['owner'] = array(
      'label' => t('Owner'),
      'description' => t('The top-level entity under which this one is embedded.'),
      'type' => 'entity',
      'getter callback' => 'cer_get_entity_owner',
      'computed' => TRUE,
    );
  }

  return $properties;
}

// Load CER's implementation of the Hierarchical Select API if Hierarchical Select
// is installed. It's a bit ugleh to include it globally like this, but as soon
// as Hierarchical Select implements hook_hook_info(), I'll get rid of it.
if (module_exists('hierarchical_select')) {
  module_load_include('inc', 'cer', 'cer.hierarchical_select');
}
