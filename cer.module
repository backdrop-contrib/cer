<?php

/**
 * Implements hook_menu().
 */
function cer_menu() {
  $items = array();
  $prefix = 'admin/config/content/cer';

  $items[$prefix] = array(
    'title' => 'Corresponding References',
    'page callback' => 'cer_preset_list',
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items["{$prefix}/presets"] = array(
    'title' => 'Presets',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 1,
  );
  $items["{$prefix}/presets/add"] = array(
    'title' => 'Add a preset',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cer_add_preset'),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_LOCAL_ACTION,
  );
  $items["{$prefix}/presets/toggle/%cer_preset"] = array(
    'page callback' => 'cer_preset_toggle',
    'page arguments' => array(6),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items["{$prefix}/presets/invert/%cer_preset"] = array(
    'page callback' => 'cer_preset_invert',
    'page arguments' => array(6),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items["{$prefix}/presets/delete/%cer_preset"] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cer_delete_preset', 6),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items["{$prefix}/update"] = array(
    'title' => 'Bulk Update',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cer_bulk_update_form'),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function cer_permission() {
  return array(
    'administer cer settings' => array(
      'title' => t('Administer corresponding entity references'),
    )
  );
}

function cer_preset_load($id = NULL) {
  if (isset($id)) {
    return new CerPreset(db_select('cer')->fields('cer')->condition('id', $id)->execute()->fetchObject());
  }
  else {
    return array_map(__FUNCTION__, db_select('cer')->fields('cer', array('id'))->execute()->fetchCol());
  }
}

/**
 * Implements hook_field_delete_instance().
 */
function cer_field_delete_instance(array $instance) {
  $pattern = sprintf('%%%s:%s:%s%%', $instance['entity_type'], $instance['bundle'], $instance['field_name']);
  db_query("DELETE FROM {cer} WHERE a LIKE :pattern OR b LIKE :pattern", array(':pattern' => $pattern));
}

/**
 * Implements hook_field_delete_field().
 */
function cer_field_delete_field(array $field) {
  $pattern = '%' . $field['field_name'] . '%';
  db_query("DELETE FROM {cer} WHERE a LIKE :pattern OR b LIKE :pattern", array(':pattern' => $pattern));
}

/**
 * Implements hook_node_insert().
 */
function cer_node_insert(StdClass $node) {
  // Write access grants *before* doing CER stuff in order to prevent a race condition.
  node_access_acquire_grants($node);

  cer_processing_entity('insert', $node, 'node');

  // Now allow node_save() to write the access grants cleanly.
  db_delete('node_access')->condition('nid', $node->nid)->execute();
}

/**
 * Implements hook_entity_insert().
 */
function cer_entity_insert($entity, $type) {
  if (! function_exists("cer_{$type}_insert")) {
    cer_processing_entity('insert', $entity, $type);
  }
}

/**
 * Implements hook_entity_update().
 */
function cer_entity_update($entity, $type) {
  if (! function_exists("cer_{$type}_update")) {
    cer_processing_entity('update', $entity, $type);
  }
}

/**
 * Implements hook_entity_delete().
 */
function cer_entity_delete($entity, $type) {
  if (! function_exists("cer_{$type}_delete")) {
    cer_processing_entity('delete', $entity, $type);
  }
}

/**
 * Process a entity's corresponding entity references.
 *
 * @param string $op 
 *  The operation being performed on the entity (insert, update, or delete).
 *
 * @param object $entity
 *  The entity.
 *
 * @param string $entity_type
 *  The entity type.
 *
 * @param array $context
 *  Either the Batch API context (since this is the callback function used
 *  during bulk update) or NULL if we're not in a batch job.
 */
function cer_processing_entity($op, $entity, $entity_type, array &$context = NULL) {
  if (defined('MAINTENANCE_MODE')) {
    drupal_set_message(t('Refusing to initialize CER when global MAINTENANCE_MODE flag is set.'), 'warning');
    return;
  }

  if (is_numeric($entity)) {
    $entity = entity_load($entity_type, array($entity));
    $entity = reset($entity);
  }

  $handlers = _cer_load_handlers( new EntityDrupalWrapper($entity_type, $entity) );

  foreach ($handlers as $handler) {
    $handler->$op();
  }

  if ($context) {
    if (! isset($context['results']['count'])) {
      $context['results']['count'] = 0;
    }
    $context['results']['count']++;
  }
}

/**
 * Loads all CerPresetHandler objects that apply to the given entity. If there are
 * no applicable presets, an empty array is returned.
 */
function _cer_load_handlers(EntityDrupalWrapper $entity) {
  $handlers = array();

  $baseQuery = db_select('cer')->fields('cer')->condition('enabled', 1);

  $a = clone $baseQuery;
  $result = $a->condition('a', $entity->cer->lineage->value(), 'LIKE')->execute();

  foreach ($result as $row) {
    $handlers[] = new CerPresetHandler(new CerPreset($row), $entity);
  }

  $b = clone $baseQuery;
  $result = $b->condition('b', $entity->cer->lineage->value(), 'LIKE')->condition('bidirectional', 1)->execute();

  foreach ($result as $row) {
    $preset = new CerPreset($row);
    $handlers[] = new CerPresetHandler($preset->invert(), $entity);
  }
  
  return $handlers;
}

/**
 * Batch 'finished' callback.
 */
function cer_batch_update_existing_finished($success, $results, $operations) {
  if ($success) {
    $message = format_plural($results['count'], '1 entity processed.', '@count entities processed.');

    if (isset($results['errors'])) {
      $type = 'warning';
      foreach ($results['errors'] as $e) {
        drupal_set_message($e->getMessage(), 'error');
      }
    }
    else {
      $type = 'status';
    }
    drupal_set_message($message, $type);
  }
  else {
    // An error occurred. $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    $message = 'An error occurred while processing ' . $error_operation[0] . ' with arguments:' . print_r($error_operation[0], TRUE);
    drupal_set_message($message, 'error');
  }
}

/**
 * Implements hook_hook_info().
 */
function cer_hook_info() {
  return array(
    'cer_fields' => array(
      'group' => 'cer',
    ),
    'cer_preset_create' => array(
      'group' => 'cer',
    ),
    'cer_preset_delete' => array(
      'group' => 'cer',
    ),
  );
}

/**
 * Implements hook_query_TAG_alter().
 */
function cer_query_cer_field_parents_alter(QueryAlterableInterface $query) {
  $field = $query->getMetaData('field');
  
  // If the field is instantiated on a field collection, find the field
  // collection field(s) which contain this one.
  if ($field->inFieldCollection()) {
    $query
      ->condition('field_name', $field->instanceInfo('bundle'))
      ->addMetaData('class', 'CerFieldCollectionField');
  }
}

/**
 * Implements hook_entity_property_info().
 */
function cer_entity_property_info() {
  $properties = array();

  foreach (entity_get_info() as $entity_type => $entity_info) {
    $properties[$entity_type]['properties']['cer'] = array(
      'label' => t('CER'),
      'description' => t('Information about the entity, used internally by CER.'),
      'type' => 'struct',
      'getter callback' => 'cer_get_entity_context',
      'computed' => TRUE,
      'property info' => array(
        'lineage' => array(
          'label' => t('Context'),
          'description' => t("The entity's lineage, represented as a string."),
          'type' => 'text',
          'getter callback' => 'cer_get_entity_lineage',
          'raw getter callback' => 'cer_get_entity_lineage_array',
          'computed' => TRUE,
        ),
        'depth' => array(
          'label' => t('Depth'),
          'description' => t("How deeply the entity is embedded."),
          'type' => 'integer',
          'getter callback' => 'cer_get_entity_depth',
          'computed' => TRUE,
        ),
        'owner' => array(
          'label' => t('Owner'),
          'description' => t('The top-level entity under which this one is embedded.'),
          'type' => 'entity',
          'getter callback' => 'cer_get_entity_owner',
          'computed' => TRUE,
        ),
        'original' => array(
          'label' => t('Original'),
          'description' => t('The original entity (before update), or the current entity if an update has not occurred.'),
          'type' => 'entity',
          'getter callback' => 'cer_get_entity_original',
          'computed' => TRUE,
        ),
      ),
    );
  }

  return $properties;
}

/**
 * Entity API property callback functions
 */
 
function cer_get_entity_context($entity, array $options, $property, $entity_type, array $info) {
  return array(
    $entity_type, $entity,
  );
}

/**
 * Gets the lineage of the entity as a string, in the format
 * entity_type:bundle:field::...
 */
function cer_get_entity_lineage(array $data, array $options, $property, $data_type, array $info) {
  return implode('::', cer_get_entity_lineage_array($data, $options, $property, $data_type, $info));
}

/**
 * Gets the entity depth as an integer. Currently, this applies only to field collections.
 */
function cer_get_entity_depth(array $data, array $options, $property, $data_type, array $info) {
  if ($data[0] == 'field_collection_item') {
    return (sizeof(cer_get_entity_lineage_array($data, $options, $property, $data_type, $info)) - 1);
  }
  else {
    return 0;
  }
}

/**
 * Gets the ultimate owner of the entity as an EntityDrupalWrapper. Currently, this
 * applies only to field collections.
 */
function cer_get_entity_owner(array $data, array $options, $property, $data_type, array $info) {
  if ($data[0] == 'field_collection_item') {
    $data[0] = $data[1]->hostEntityType();
    $data[1] = $data[1]->hostEntity();

    return cer_get_entity_owner($data, $options, $property, $data_type, $info);
  }
  else {
    return new EntityDrupalWrapper($data[0], $data[1]);
  }
}

/**
 * Recursively computes the lineage of an entity and returns it as an array of strings
 * in the format entity_type:bundle:field.
 */
function cer_get_entity_lineage_array(array $data, array $options, $property, $data_type, array $info) {
  list(, , $bundle) = entity_extract_IDs($data[0], $data[1]);

  if (! isset($options['lineage'])) {
    $options['lineage'] = array( $data[0] . ":{$bundle}:%" );
  }

  if ($data[0] == 'field_collection_item') {
    $data[0] = $data[1]->hostEntityType();
    $data[1] = $data[1]->hostEntity();
    list(, , $hostBundle) = entity_extract_IDs($data[0], $data[1]);
    array_unshift($options['lineage'], $data[0] . ":{$hostBundle}:{$bundle}");

    return cer_get_entity_lineage_array($data, $options, $property, $data_type, $info);
  }
  else {
    return $options['lineage'];
  }
}

/**
 * Gets the original entity, before update. If no update has taken place, the current
 * entity is returned.
 */
function cer_get_entity_original(array $data, array $options, $property, $data_type, array $info) {
  return new EntityDrupalWrapper($data[0], (isset($data[1]->original) ? $data[1]->original : $data[1]));
}

// Load CER's implementation of the Hierarchical Select API if Hierarchical Select
// is installed. It's a bit ugleh to include it globally like this, but as soon
// as Hierarchical Select implements hook_hook_info(), I'll get rid of it.
if (module_exists('hierarchical_select')) {
  module_load_include('inc', 'cer', 'cer.hierarchical_select');
}
