<?php

/**
 * Implements hook_menu().
 */
function cer_menu() {
  $items = array();
  $prefix = 'admin/config/content/cer';

  $items[$prefix] = array(
    'title' => 'Corresponding References',
    'page callback' => 'cer_preset_list',
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items["{$prefix}/presets"] = array(
    'title' => 'Presets',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 1,
  );
  $items["{$prefix}/presets/add"] = array(
    'title' => 'Add a preset',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cer_add_preset'),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_LOCAL_ACTION,
  );
  $items["{$prefix}/presets/toggle/%cer_preset"] = array(
    'page callback' => 'cer_preset_toggle',
    'page arguments' => array(6),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items["{$prefix}/presets/delete/%cer_preset"] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cer_delete_preset', 6),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items["{$prefix}/update"] = array(
    'title' => 'Bulk Update',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cer_bulk_update_form'),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function cer_permission() {
  return array(
    'administer cer settings' => array(
      'title' => t('Administer corresponding entity references'),
    )
  );
}

function cer_preset_load($id = NULL) {
  if (isset($id)) {
    return new CerPreset(db_select('cer')->fields('cer')->condition('id', $id)->execute()->fetchObject());
  }
  else {
    return array_map(__FUNCTION__, db_select('cer')->fields('cer', array('id'))->execute()->fetchCol());
  }
}

/**
 * Implements hook_field_delete_instance().
 */
function cer_field_delete_instance(array $instance) {
  $pattern = sprintf('%%%s:%s:%s%%', $instance['entity_type'], $instance['bundle'], $instance['field_name']);
  db_query("DELETE FROM {cer} WHERE a LIKE :pattern OR b LIKE :pattern", array(':pattern' => $pattern));
}

/**
 * Implements hook_field_delete_field().
 */
function cer_field_delete_field(array $field) {
  $pattern = '%' . $field['field_name'] . '%';
  db_query("DELETE FROM {cer} WHERE a LIKE :pattern OR b LIKE :pattern", array(':pattern' => $pattern));
}

/**
 * Implements hook_node_insert().
 */
function cer_node_insert(StdClass $node) {
  // Write access grants *before* doing CER stuff in order to prevent a race condition.
  node_access_acquire_grants($node);

  cer_processing_entity('insert', $node, 'node');

  // Now allow node_save() to write the access grants cleanly.
  db_delete('node_access')->condition('nid', $node->nid)->execute();
}

/**
 * Implements hook_entity_insert().
 */
function cer_entity_insert($entity, $type) {
  if ($type != 'node') {
    cer_processing_entity('insert', $entity, $type);
  }
}

/**
 * Implements hook_entity_update().
 */
function cer_entity_update($entity, $type) {
  cer_processing_entity('update', $entity, $type);
}

/**
 * Implements hook_entity_delete().
 */
function cer_entity_delete($entity, $type) {
  cer_processing_entity('delete', $entity, $type);
}

/**
 * Process a entity's corresponding entity references.
 *
 * @param string $op 
 *  The operation being performed on the entity (insert, update, or delete).
 *
 * @param object $entity
 *  The entity.
 *
 * @param string $entity_type
 *  The entity type.
 *
 * @param array $context
 *  Either the Batch API context (since this is the callback function used
 *  during bulk update) or NULL if we're not in a batch job.
 */
function cer_processing_entity($op, $entity, $entity_type, array &$context = NULL) {
  if (is_integer($entity)) {
    $entity = entity_load($entity_type, array($entity));
    $entity = reset($entity);
  }

  $presets = new CER($entity_type, $entity);

  foreach ($presets as $key => $preset) {
    $preset->$op();
  }

  if ($context) {
    if (! isset($context['results']['count'])) {
      $context['results']['count'] = 0;
    }
    $context['results']['count']++;
  }
}

/**
 * Batch 'finished' callback.
 */
function cer_batch_update_existing_finished($success, $results, $operations) {
  if ($success) {
    $message = format_plural($results['count'], '1 entity processed.', '@count entities processed.');

    if (isset($results['errors'])) {
      $type = 'warning';
      foreach ($results['errors'] as $e) {
        drupal_set_message($e->getMessage(), 'error');
      }
    }
    else {
      $type = 'status';
    }
    drupal_set_message($message, $type);
  }
  else {
    // An error occurred. $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    $message = 'An error occurred while processing ' . $error_operation[0] . ' with arguments:' . print_r($error_operation[0], TRUE);
    drupal_set_message($message, 'error');
  }
}

/**
 * Implements hook_hook_info().
 */
function cer_hook_info() {
  return array(
    'cer_fields' => array(
      'group' => 'cer',
    ),
    'cer_preset_create' => array(
      'group' => 'cer',
    ),
    'cer_preset_delete' => array(
      'group' => 'cer',
    ),
  );
}

/**
 * Implements hook_cer_preset_create().
 */
function cer_cer_preset_create(CerPreset $preset) {
  // Prevents a race condition when deleting Commerce products which are referred to
  // by Product Reference fields managed by CER.
  if ($preset->right()->end() instanceof CerCommerceProductReferenceField) {
    drupal_set_message(t('In order to prevent a race condition, bidirectionality has been disabled for this preset.'), 'warning');
    $preset->bidirectional = FALSE;
  }
}

/**
 * Implements hook_cer_fields().
 */
function cer_cer_fields() {
  $fields = array();

  if (module_exists('taxonomy')) {
    $fields = array_merge($fields, _cer_collect_fields_of_type('taxonomy_term_reference', 'CerTaxonomyTermReferenceField'));
  }
  if (module_exists('entityreference')) {
    $fields = array_merge($fields, _cer_collect_fields_of_type('entityreference', 'CerEntityReferenceField'));
  }
  if (module_exists('node_reference')) {
    $fields = array_merge($fields, _cer_collect_fields_of_type('node_reference', 'CerNodeReferenceField'));
  }
  if (module_exists('user_reference')) {
    $fields = array_merge($fields, _cer_collect_fields_of_type('user_reference', 'CerUserReferenceField'));
  }
  if (module_exists('commerce_product_reference')) {
    $fields = array_merge($fields, _cer_collect_fields_of_type('commerce_product_reference', 'CerCommerceProductReferenceField'));
  }
  if (module_exists('file')) {
    $fields = array_merge($fields, _cer_collect_fields_of_type('file', 'CerFileField'));
  }
  if (module_exists('image')) {
    $fields = array_merge($fields, _cer_collect_fields_of_type('image', 'CerFileField'));
  }

  return $fields;
}

/**
 * Implements hook_query_TAG_alter().
 */
function cer_query_cer_field_parents_alter(QueryAlterableInterface $query) {
  $field = $query->getMetaData('field');
  
  // If the field is instantiated on a field collection, find the field
  // collection field(s) which contain this one.
  if ($field->inFieldCollection()) {
    $query
      ->condition('field_name', $field->instanceInfo('bundle'))
      ->addMetaData('class', 'CerFieldCollectionField');
  }
}

/**
 * Implements hook_hierarchical_select_params().
 */
function cer_hierarchical_select_params() {
  return CerFieldHierarchy::getParameters();
}

/**
 * Implements hook_hierarchical_select_root_level().
 */
function cer_hierarchical_select_root_level($parameters) {
  return CerFieldHierarchy::get($parameters['id'])->getOptions(CerFieldHierarchy::ROOT);
}

/**
 * Implements hook_hierarchical_select_children().
 */
function cer_hierarchical_select_children($parent, $parameters) {
  return CerFieldHierarchy::get($parameters['id'])->getOptions($parent);
}

/**
 * Implements hook_hierarchical_select_lineage().
 */
function cer_hierarchical_select_lineage($item, $parameters) {
  return CerFieldHierarchy::get($parameters['id'])->getLineage($item);
}

/**
 * Implements hook_hierarchical_select_valid_item().
 */
function cer_hierarchical_select_valid_item($item, $parameters) {
  return CerFieldHierarchy::get($parameters['id'])->validItem($item);
}

/**
 * Implements hook_hierarchical_select_item_get_label().
 */
function hook_hierarchical_select_item_get_label($item, $parameters) {
  return CerFieldHierarchy::get($parameters['id'])->getLabel($item);
}
