<?php

/**
 * Implements hook_menu().
 */
function cer_menu() {
  $items = array();
  $prefix = 'admin/config/content/cer';

  $items[$prefix] = array(
    'title' => 'Corresponding References',
    'page callback' => 'cer_preset_list',
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items["{$prefix}/presets"] = array(
    'title' => 'Presets',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 1,
  );
  $items["{$prefix}/presets/add"] = array(
    'title' => 'Add a preset',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cer_add_preset'),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_LOCAL_ACTION,
  );
  $items["{$prefix}/presets/toggle/%cer_preset"] = array(
    'page callback' => 'cer_preset_toggle',
    'page arguments' => array(6),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items["{$prefix}/presets/invert/%cer_preset"] = array(
    'page callback' => 'cer_preset_invert',
    'page arguments' => array(6),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items["{$prefix}/presets/delete/%cer_preset"] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cer_delete_preset', 6),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items["{$prefix}/update"] = array(
    'title' => 'Bulk Update',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cer_bulk_update_form'),
    'access arguments' => array('administer cer settings'),
    'file' => 'cer.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );

  return $items;
}

/**
 * Load callback for %cer_preset wildcards.
 */
function cer_preset_load($id) {
  ctools_include('export');
  return ctools_export_crud_load('cer', $id);
}

/**
 * Implements hook_permission().
 */
function cer_permission() {
  return array(
    'administer cer settings' => array(
      'title' => t('Administer corresponding entity references'),
    )
  );
}

/**
 * Implements hook_field_delete_instance().
 */
function cer_field_delete_instance(array $instance) {
  $pattern = sprintf('%%%s:%s:%s%%', $instance['entity_type'], $instance['bundle'], $instance['field_name']);
  db_query("DELETE FROM {cer} WHERE a LIKE :pattern OR b LIKE :pattern", array(':pattern' => $pattern));
}

/**
 * Implements hook_field_delete_field().
 */
function cer_field_delete_field(array $field) {
  $pattern = '%' . $field['field_name'] . '%';
  db_query("DELETE FROM {cer} WHERE a LIKE :pattern OR b LIKE :pattern", array(':pattern' => $pattern));
}

/**
 * Implements hook_node_insert().
 */
function cer_node_insert(StdClass $node) {
  // Write access grants *before* doing CER stuff in order to prevent a race condition.
  node_access_acquire_grants($node);

  cer_processing_entity('insert', $node, 'node');

  // Now allow node_save() to write the access grants cleanly.
  db_delete('node_access')->condition('nid', $node->nid)->execute();
}

/**
 * Implements hook_entity_insert().
 */
function cer_entity_insert($entity, $type) {
  if (! function_exists("cer_{$type}_insert")) {
    cer_processing_entity('insert', $entity, $type);
  }
}

/**
 * Implements hook_entity_update().
 */
function cer_entity_update($entity, $type) {
  if (! function_exists("cer_{$type}_update")) {
    cer_processing_entity('update', $entity, $type);
  }
}

/**
 * Implements hook_entity_delete().
 */
function cer_entity_delete($entity, $type) {
  if (! function_exists("cer_{$type}_delete")) {
    cer_processing_entity('delete', $entity, $type);
  }
}

/**
 * Process a entity's corresponding entity references.
 *
 * @param string $op 
 *  The operation being performed on the entity (insert, update, or delete).
 *
 * @param object $entity
 *  The entity.
 *
 * @param string $entity_type
 *  The entity type.
 *
 * @param array $context
 *  Either the Batch API context (since this is the callback function used
 *  during bulk update) or NULL if we're not in a batch job.
 */
function cer_processing_entity($op, $entity, $entity_type, array &$context = NULL) {
  if (defined('MAINTENANCE_MODE')) {
    drupal_set_message(t('Refusing to initialize CER when global MAINTENANCE_MODE flag is set.'), 'warning');
    return;
  }

  if (is_numeric($entity)) {
    $entity = entity_load($entity_type, array($entity));
    $entity = reset($entity);
  }

  $handlers = _cer_load_handlers( new EntityDrupalWrapper($entity_type, $entity) );

  foreach ($handlers as $handler) {
    $handler->$op();
  }

  if ($context) {
    if (! isset($context['results']['count'])) {
      $context['results']['count'] = 0;
    }
    $context['results']['count']++;
  }
}

/**
 * Loads all CerPresetHandler objects that apply to the given entity. If there are
 * no applicable presets, an empty array is returned.
 */
function _cer_load_handlers(EntityDrupalWrapper $entity) {
  $handlers = array();

  $baseQuery = db_select('cer')->fields('cer')->condition('enabled', 1);

  $a = clone $baseQuery;
  $result = $a->condition('a', $entity->cer->lineage->value(), 'LIKE')->execute();

  foreach ($result as $row) {
    $handlers[] = new CerPresetHandler(new CerPreset($row), $entity);
  }

  $b = clone $baseQuery;
  $result = $b->condition('b', $entity->cer->lineage->value(), 'LIKE')->condition('bidirectional', 1)->execute();

  foreach ($result as $row) {
    $preset = new CerPreset($row);
    $handlers[] = new CerPresetHandler($preset->invert(), $entity);
  }
  
  return $handlers;
}

/**
 * Batch 'finished' callback.
 */
function cer_batch_update_existing_finished($success, $results, $operations) {
  if ($success) {
    $message = format_plural($results['count'], '1 entity processed.', '@count entities processed.');

    if (isset($results['errors'])) {
      $type = 'warning';
      foreach ($results['errors'] as $e) {
        drupal_set_message($e->getMessage(), 'error');
      }
    }
    else {
      $type = 'status';
    }
    drupal_set_message($message, $type);
  }
  else {
    // An error occurred. $operations contains the operations that remained unprocessed.
    $error_operation = reset($operations);
    $message = 'An error occurred while processing ' . $error_operation[0] . ' with arguments:' . print_r($error_operation[0], TRUE);
    drupal_set_message($message, 'error');
  }
}

/**
 * Implements hook_hook_info().
 */
function cer_hook_info() {
  return array(
    'cer_fields' => array(
      'group' => 'cer',
    ),
    'cer_fields_alter' => array(
      'group' => 'cer',
    ),
    'cer_default_presets' => array(
      'group' => 'cer',
    ),
    'cer_default_presets_alter' => array(
      'group' => 'cer',
    ),
    'cer_preset_create' => array(
      'group' => 'cer',
    ),
    'cer_preset_toggle' => array(
      'group' => 'cer',
    ),
    'cer_preset_delete' => array(
      'group' => 'cer',
    ),
  );
}

/**
 * Implements hook_features_api().
 */
function cer_features_api() {
  module_load_include('inc', 'features', 'includes/features.ctools');

  $API = ctools_component_features_api('cer');
  $API['cer']['file'] = drupal_get_path('module', 'cer') . '/cer.features.inc';
  $API['cer']['default_filename'] = 'cer';

  return $API;
}

/**
 * CTools Export API functions
 */

/**
 * 'list callback' function.
 */
function _cer_preset_list() {
  $list = array();

  $presets = ctools_export_crud_load_all('cer');
  foreach ($presets as $preset) {
    $list[ $preset->id ] = sprintf('%s <> %s', html_entity_decode($preset->left->getLabel()), html_entity_decode($preset->right->getLabel()));
  }

  return $list;
}

/**
 * Exports a CerFieldChain as a string.
 */
function _cer_export_chain(CerPreset $preset, $field, CerFieldChain $value, $indent) {
  return "'{$value}'";
}

/**
 * Implements hook_entity_property_info().
 */
function cer_entity_property_info() {
  $properties = array();

  foreach (entity_get_info() as $entity_type => $entity_info) {
    $properties[$entity_type]['properties']['cer'] = array(
      'label' => t('CER'),
      'description' => t('Information about the entity, used internally by CER.'),
      'type' => 'struct',
      'getter callback' => 'cer_get_cer_struct',
      'computed' => TRUE,
      'property info' => array(
        'lineage' => array(
          'label' => t('Context'),
          'description' => t("The entity's lineage, represented as a string."),
          'type' => 'text',
          'getter callback' => 'cer_get_entity_lineage',
          'computed' => TRUE,
        ),
        'depth' => array(
          'label' => t('Depth'),
          'description' => t("How deeply the entity is embedded."),
          'type' => 'integer',
          'getter callback' => 'cer_get_entity_depth',
          'computed' => TRUE,
        ),
        'owner' => array(
          'label' => t('Owner'),
          'description' => t('The top-level entity under which this one is embedded.'),
          'type' => 'entity',
          'getter callback' => 'cer_get_entity_owner',
          'computed' => TRUE,
        ),
        'original' => array(
          'label' => t('Original'),
          'description' => t('The original entity (before update), or the current entity if an update has not occurred.'),
          'type' => 'entity',
          'getter callback' => 'cer_get_entity_original',
          'computed' => TRUE,
        ),
      ),
    );
  }

  return $properties;
}

/**
 * Implements hook_entity_property_info_alter().
 */
function cer_entity_property_info_alter(array &$info) {
  if (module_exists('field_collection')) {
    $struct = &$info['field_collection_item']['properties']['cer']['property info'];

    $struct['lineage']['getter callback'] = 'cer_get_field_collection_lineage';
    $struct['lineage']['raw getter callback'] = 'cer_get_field_collection_lineage_array';
    $struct['depth']['getter callback'] = 'cer_get_field_collection_depth';
    $struct['owner']['getter callback'] = 'cer_get_field_collection_owner';
  }
}

// Include property callback functions
module_load_include('inc', 'cer', 'cer.properties');

// Load CER's implementation of the Hierarchical Select API if Hierarchical Select
// is installed. It's a bit ugleh to include it globally like this, but as soon
// as Hierarchical Select implements hook_hook_info(), I'll get rid of it.
if (module_exists('hierarchical_select')) {
  module_load_include('inc', 'cer', 'cer.hierarchical_select');
}

// Include CER's Features API implementation. The reason we can't let Features auto-load
// it is because Features tries to automatically implement cer_features_export() before
// it tries to autoload the file, resulting in a "function already declared" fatal error. 
if (module_exists('features')) {
  module_load_include('inc', 'cer', 'cer.features');
}
